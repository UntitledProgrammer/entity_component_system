#include "grid.h"
#include "../Constraints.h"

#define DEFAULT_WIDTH 100
#define DEFAULT_HEIGHT 100

Grid::Grid(unsigned int rows, unsigned int columns, sf::Vector2f scale) : scale(scale)
{
	components.resize(columns);
	for (int i = 0; i < columns; i++) { components[i].resize(rows); }
}

Grid* Grid::get_singleton()
{
	if (!singleton) singleton = new Grid(DEFAULT_WIDTH, DEFAULT_HEIGHT, sf::Vector2f(5,5));
	return singleton;
}

void Grid::set(unsigned int x, unsigned int y, bool value)
{
	assert(x / scale.x < components.size() && y / scale.y < components[x].size());
	components[x / scale.x][y / scale.y] = value;
}

void Grid::set(sf::Vector2u position, bool value)
{
	assert((position.x / scale.x) < components.size() && (position.y / scale.y) < components[position.x / scale.x].size());
	components[position.x / scale.x][position.y / scale.y] = value;
}

bool Grid::get(sf::Vector2u position)
{
	assert((position.x / scale.x) < components.size() && (position.y / scale.y) < components[position.x / scale.x].size());
	return components[position.x / scale.x][position.y / scale.y];
}

bool Grid::get(unsigned int x, unsigned int y)
{
	return components[x][y];
}

void Grid::flip(sf::Vector2u position)
{
	assert((position.x / scale.x) < components.size() && (position.y / scale.y) < components[position.x / scale.x].size());
	components[position.x / scale.x][position.y / scale.y] = !components[position.x / scale.x][position.y / scale.y];
}

bool Grid::in_range(sf::Vector2u position)
{
	return (position.x / scale.x) < components.size() && (position.y / scale.y) < components.front().size();
}

void Grid::draw(sf::RenderTarget& target, sf::RenderStates states) const
{
	sf::RectangleShape shape = sf::RectangleShape(scale);
	shape.setFillColor(sf::Color::Green);

	for (int i = 0; i < components.size(); i++)
	{
		for (int j = 0; j < components[i].size(); j++)
		{
			if (!components[i][j]) continue;
			shape.setPosition(i * scale.x, j * scale.y);
			target.draw(shape);
		}
	}
}

Grid* Grid::singleton = nullptr;